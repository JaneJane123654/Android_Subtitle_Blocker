---
name: 修复实现方案文档
overview: 修复字幕遮挡器实现方案文档中的8个重要问题：架构依赖矛盾、伪代码逻辑错误、性能指标不合理、Android 14适配缺失、数据存储设计缺陷、测试策略不完整、错误处理不明确、动画实现细节缺失
todos:
  - id: fix-architecture-dependency
    content: 修复架构依赖规则描述，澄清接口依赖与实现依赖的关系
    status: completed
  - id: fix-pseudocode-logic
    content: 修正伪代码时序逻辑，分离实时更新与动画更新
    status: completed
    dependencies:
      - fix-architecture-dependency
  - id: adjust-performance-metrics
    content: 调整性能指标为符合实际设备的合理值
    status: completed
  - id: supplement-android14-adapter
    content: 补充Android 14适配的具体实现细节（前台服务类型、通知权限）
    status: completed
  - id: enhance-data-storage
    content: 完善数据存储设计，添加并发控制和版本迁移策略
    status: completed
  - id: expand-test-coverage
    content: 扩展测试用例覆盖范围，补充边界场景和异常路径
    status: completed
  - id: clarify-error-handling
    content: 明确三级错误处理机制，定义具体场景的处理策略
    status: completed
  - id: detail-animation-implementation
    content: 补充动画实现的技术细节和代码示例
    status: completed
  - id: verify-code-consistency
    content: 使用[code-explorer]验证app/目录下代码结构与修复后的文档一致
    status: completed
---

## 产品概述

修复字幕遮挡器应用实现方案文档中的8个重要问题，使文档具备更好的指导性和可执行性。

## 核心功能

- 修复架构依赖规则与架构图的矛盾，明确各层依赖关系
- 修正伪代码中的时序逻辑问题，确保拖动/缩放动画策略正确
- 调整性能指标为合理的预期值，符合实际设备表现
- 补充Android 14适配的具体实现细节（前台服务类型、通知权限等）
- 完善数据存储设计，添加并发控制、版本迁移策略
- 扩展测试用例覆盖范围，补充边界场景和异常路径
- 明确错误处理机制，定义各级异常处理策略
- 补充动画实现的具体技术细节和代码示例

## 技术栈

- 文档修复：Markdown 文档编辑
- 代码验证：无需编译验证，仅修正文档中的技术描述

## 文档修复架构

### 问题分类与修复策略

```
文档修复计划
        |
        +----------------------+----------------------+
        |                      |                      |
  架构层修复              逻辑层修复              实现层修复
- 依赖规则澄清           - 伪代码时序修正         - 动画实现细节
- Android 14适配         - 性能指标调整          - 错误处理机制
        |                      |                      |
        +----------------------+----------------------+
                            |
                    测试与验证层修复
                    - 测试用例扩展
                    - 数据存储完善
```

## 修复详情

### 1. 架构依赖规则修复（第125-129行）

**问题**：依赖规则描述不够明确，未区分"依赖接口"与"依赖实现"
**修复方案**：

- 明确分层依赖：UI → ViewModel → Domain → (Platform/Data抽象)
- 强调依赖倒置原则：Domain只依赖Platform/Data的接口，不依赖具体实现
- 补充说明：Platform层依赖FloatingX/SharedPreferences具体实现

### 2. 伪代码时序修复（第260-287行）

**问题**：`emit()`调用时机不明确，"only_on_drag_end"表述混淆
**修复方案**：

- 分离实时更新与动画更新逻辑
- 拖动/缩放过程：直接设置state，不传动画参数（立即生效）
- 拖动/缩放结束：调用`emit(state, anim=MOVE/RESIZE)`触发动画
- 补充完整的状态转换流程说明

### 3. 性能指标调整（第87行）

**原指标**：交互响应延迟<100ms；动画60fps；峰值内存<60MB；交互时CPU<15%
**调整后**：

- 交互响应延迟≤150ms（考虑中端设备实际情况）
- 动画≥50fps（可接受范围）
- 峰值内存≤80MB（预留缓冲）
- 交互时CPU≤25%（更现实的预期）

### 4. Android 14适配补充（第165、172行）

**补充内容**：

- 前台服务类型：`FOREGROUND_SERVICE_TYPE_MEDIA_PROJECTION`
- 通知权限：Android 13+需`POST_NOTIFICATIONS`权限
- 前台服务启动时机：在悬浮窗显示前启动
- 通知栏展示：必须提供持续型通知，说明用途并提供关闭按钮
- 服务限制：`startForegroundService()`需在5秒内调用`startForeground()`

### 5. 数据存储设计完善（第235-239行）

**新增内容**：

- 并发控制：使用`apply()`替代`commit()`以避免主线程阻塞
- 数据校验：读取时验证数值合理性（如超出屏幕范围则使用默认值）
- 版本迁移策略：添加`prefs_version`字段，定义迁移函数`migrateFromVersion(int oldVersion)`
- 异常处理：`loadLastOverlayState()`返回null时提供默认状态
- 线程安全：确保Repository方法可从任意线程调用

### 6. 测试用例扩展（第328-352行）

**新增用例**：

- **单元测试补充**：
- `clampSize`负值输入测试
- `clampPosition`零尺寸窗口测试
- `snapToEdgeIfNeeded`边界阈值测试
- `OverlayViewModel`快速连续事件测试（防抖）
- `SettingsRepository`版本迁移测试
- **集成测试补充**：
- 权限被撤销后重试流程
- 系统杀死进程后重启恢复
- 多次旋转快速切换场景
- 低内存情况下的稳定性
- 前台服务被系统强制停止的处理

### 7. 错误处理机制明确（第232行）

**定义三级异常处理**：

- **Platform层**：捕获系统异常（SecurityException, WindowManager.BadTokenException等），转换为结果对象或抛出领域异常
- **Domain层**：统一记录日志，执行降级策略（如窗口更新失败→hide并提示）
- **UI层**：捕获UI线程异常，避免崩溃，提供用户友好提示
- **具体场景**：
- 权限拒绝：引导用户前往设置
- 窗口更新失败：隐藏悬浮窗并记录日志
- 服务启动失败：回退到非保活模式并提示
- 存储读写失败：使用默认值并记录警告

### 8. 动画实现细节补充（第292行）

**新增内容**：

- **拖动动画**：使用`ValueAnimator`配合`View.layout()`实现平滑移动，150ms
- **缩放动画**：使用`ObjectAnimator`动画化width/height，200ms
- **关闭渐隐**：使用`ViewPropertyAnimator.alpha(0f).setDuration(300ms)`
- **性能优化**：
- 动画过程禁用重绘监听
- 使用硬件加速层`setLayerType(LAYER_TYPE_HARDWARE, null)`
- 动画结束后恢复`LAYER_TYPE_NONE`
- **代码示例**：

```java
// 拖动结束动画示例
ValueAnimator moveAnim = ValueAnimator.ofFloat(startX, targetX);
moveAnim.setDuration(150);
moveAnim.addUpdateListener(animation -> {
    float progress = animation.getAnimatedFraction();
    float currentX = startX + (targetX - startX) * progress;
    view.setLeft((int)currentX);
    view.setRight((int)(currentX + view.getWidth()));
});
moveAnim.start();
```

## Agent Extensions

### SubAgent

- **code-explorer**
- Purpose: 验证app/目录下的Java代码结构，确保文档修复与实际代码保持一致
- Expected outcome: 确认现有代码分层架构与修复后的文档描述匹配