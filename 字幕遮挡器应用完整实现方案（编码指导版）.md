toolName: todo_write
            
status: success
          
Todos updated: 5 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 5 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 5 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 5 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 5 items
          

        
            
toolName: todo_write
            
status: success
          
Todos updated: 5 items
          
# 字幕遮挡器应用完整实现方案（编码指导版）

## 1. 项目概述与目标
- **目标**：在 Android 5.0+（API 21）提供"始终浮于其他应用之上"的字幕遮挡区域；Android 14 作为主要适配目标，兼顾向下兼容。
- **核心体验**：纯黑 100% 不透明遮挡 + 1px 浅灰描边；支持拖动、缩放、边缘吸附、关闭渐隐、关闭按钮位置可配置、可选音效；旋转自适应；后台保活；完善日志；核心单测覆盖≥80%。
- **关键约束**：Java 8；FloatingX 2.3.7+；架构采用 MVVM（或 MVP，但两份文档已明确偏向 MVVM）。

## 2. 需求总结（功能性与非功能性）

### 2.1 功能性需求
- **悬浮遮挡**：遮挡区域可在屏幕任意位置显示，且始终在其他应用之上。
- **视觉**：
  - 背景：RGB(0,0,0)，不透明度 100%。
  - 边框：1px 浅灰描边（提升边界识别）。
- **尺寸调节**：
  - 右下角 24dp×24dp 调节手柄，拖拽改变宽高。
  - 尺寸动画：200ms 平滑过渡（至少在"结束/收敛"阶段保证 200ms 视觉效果）。
  - 最小：≥100dp×40dp；最大：≤屏幕 80%。
- **位置调节**：
  - 长按 + 拖动整体移动。
  - 移动动画：150ms 平滑。
  - 边缘吸附：距离边缘 15dp 内自动对齐。
  - 屏幕边界限制：任何部分不可超出可视区域（需考虑安全区/刘海/手势栏 insets）。
- **控制**：
  - 关闭按钮：圆形 32dp，白色"×"；位置可选右上/左上。
  - 关闭动画：渐隐 300ms，结束后销毁/隐藏悬浮窗。
- **设置**：
  - 关闭按钮位置（右上/左上）。
  - 音效开关（可选）。
- **适配**：
  - 主流屏幕尺寸 4.7–10.1 英寸；旋转自适应。
  - 权限差异：悬浮窗权限需引导用户手动开启，处理不同版本差异。
- **后台保活**：后台播放视频时遮挡器保持可用（以系统允许的合规方式）。

### 2.2 非功能性需求
- **性能**：交互响应延迟 ≤150ms；动画 ≥50fps（目标60fps，但需考虑低端设备降级）；峰值内存 ≤80MB；交互时 CPU ≤25%（以中端机为参考的目标）。
  - 注：在低端设备上允许适当降级（如动画降至30fps），通过性能监控自动检测并调整。
  - 性能监控建议：在 debug 版本记录关键帧率、内存占用、响应延迟日志。
- **可维护性**：Google Java 规范；关键复杂逻辑要有"为什么"注释（项目要求）。
- **可观测性**：详细日志，关键路径可追踪（权限/显示/更新/关闭/保活）。
- **稳定性**：覆盖异常路径（权限拒绝、窗口更新失败、旋转频繁、进程重启）。

## 3. 技术栈与环境说明
- **语言/平台**：Java 8，Android API 21+。
- **核心三方**：FloatingX 2.3.7+（悬浮窗能力封装）。
- **架构**：MVVM（UI 轻逻辑，状态机在 VM/Domain）。
- **数据存储**：优先 SharedPreferences（简单稳定、满足设置/最后状态持久化）；若项目已使用 DataStore 可替换，但不强制引入新栈。
- **部署**：标准 Android APK；无服务器部署要求。

> 说明：此应用本质为"本地端 + 系统服务交互"，不存在典型 Web 的前后端分离。文档中的"前后端交互"章节将以"UI 层（前端）⇄ 领域/平台层（后端能力）"的内部契约来描述。

## 4. 系统架构（模块边界、依赖与数据流）

### 4.1 架构图（文本版）
```
UI(Activity/Fragment/OverlayView)
        |
        v   (事件/意图 Intent)
ViewModel (OverlayViewModel)
        |
        v   (UseCase/Interactor 调用)
Domain  (OverlayInteractor / UseCases)
        |
        +---------------------+
        |                     |
        v                     v
Platform(权限/屏幕/悬浮窗)     Data(设置/音效)
PermissionNavigator           SettingsRepository
ScreenInfoProvider            SoundPlayer
FloatWindowController(FloatingX)
        |
        v
FloatingX / WindowManager / ForegroundService
```

### 4.2 依赖规则（强制）
- **UI 层**：只能依赖 ViewModel，不直接依赖 FloatingX、SharedPreferences。
- **ViewModel 层**：只依赖 Domain 的 UseCase 接口与纯计算组件（clamp/snap），不触碰 Android Context（除非通过依赖注入的接口）。
- **Domain 层**：依赖 Platform/Data 的抽象接口（遵循依赖倒置原则，便于测试替身），不依赖具体实现类。Domain 负责业务逻辑编排和约束计算。
- **Platform 层**：提供 Platform 抽象接口的具体实现（如 FloatWindowControllerImpl），是唯一直接触碰 Android API/FloatingX/服务的地方。
- **依赖关系图**：UI → ViewModel → Domain → (Platform/Data接口) ← Platform/Data实现
  - Domain 定义接口（如 IFloatWindowController），Platform 提供实现（如 FloatWindowControllerImpl）
  - 通过依赖注入实现接口与实现的绑定

## 5. 模块/组件设计（职责与边界）

### 5.1 UI 模块
1) **MainActivity / SettingsActivity（或单 Activity + Fragment）**
- 职责：权限引导入口、设置入口、启动/停止遮挡器。
- 只做事件转发与渲染状态（不承载复杂约束逻辑）。

2) **OverlayWindowView（悬浮窗内容 View）**
- 结构：黑色背景容器 + 1px 描边；右下 resize handle；close button（左上/右上）。
- 职责：接收触摸事件（drag/resize/close），转为标准化事件发给 VM；根据 VM 下发状态更新自身布局与动画。

3) **OverlayViewBinder（可选）**
- 职责：将 `OverlayState` 映射为 View 的布局参数（x/y/w/h、按钮位置、可见性、动画执行）。
- 好处：UI 更新逻辑集中，便于做 UI 级单测/快照（若引入）。

### 5.2 ViewModel 模块
**OverlayViewModel**
- 输入：UI 事件（开始拖动/拖动中/结束拖动；开始缩放/缩放中/结束缩放；关闭点击；旋转/屏幕变化；设置变更）。
- 输出：`OverlayState`（单一可信源）+ `OneShotEffect`（一次性事件：播放音效、触发关闭动画结束后销毁等）。
- 内部：状态机、约束计算、吸附逻辑、动画参数选择、持久化触发时机。

### 5.3 Domain 模块
**OverlayInteractor（或拆为多个 UseCase）**
- `showOverlay()`：检查权限→创建/显示悬浮窗→恢复上次状态→启动保活（如启用）。
- `hideOverlay()`：触发关闭动画→隐藏/销毁悬浮窗→停止保活（可选）。
- `updateSettings(Settings)`：保存设置→通知 VM 更新 close button 位置/音效开关。

### 5.4 Platform 模块
1) **FloatWindowController（封装 FloatingX）**
- 目标：把 FloatingX 的 Builder/生命周期/更新 API 封装起来，统一错误处理与日志。
- 负责：show/hide/update/layout params、对异常做降级（失败时回退为 hide 并提示）。

2) **PermissionNavigator**
- 负责：检测悬浮窗权限、发起系统设置页跳转、回调处理。
- Android 14+ 适配细节：
  - 前台服务类型：必须在 Manifest 中声明 `android:foregroundServiceType="mediaProjection"`
  - 通知权限：Android 13+ 需动态请求 `POST_NOTIFICATIONS` 权限（用于前台服务通知）
  - 悬浮窗权限：Android 14 对悬浮窗权限检查更严格，需在启动前确认权限状态
  - 实现建议：使用 `ActivityCompat.requestPermissions()` 动态请求通知权限，结果通过 `onRequestPermissionsResult()` 回调处理

3) **ScreenInfoProvider**
- 负责：获取屏幕尺寸、密度、rotation、WindowInsets/safeInsets。
- 输出：`ScreenBounds(widthPx,heightPx,safeInsets)`。

4) **KeepAliveService（前台服务）**
- 负责：需要时启动前台服务以提升进程存活；必须合规展示通知；处理 Android 14 的限制（前台服务类型、启动时机）。
- Android 14 适配具体要求：
  - Manifest 声明：`<service android:foregroundServiceType="mediaProjection" ... />`
  - 通知栏展示：必须提供持续型通知，明确说明"字幕遮挡器正在运行"，并提供关闭按钮
  - 服务启动时机：在悬浮窗显示前启动 `startForegroundService()`，并在 5 秒内调用 `startForeground()`
  - 通知权限：启动前检查 `POST_NOTIFICATIONS` 权限，未授权则提示用户前往设置或降级为非保活模式
- 注意：保活"确保后台播放视频时可用"更多是"降低被杀概率"，无法 100% 保证，这是系统限制，需在风险章节说明。

### 5.5 Data 模块
1) **SettingsRepository**
- 持久化：closeButtonPosition、soundEnabled、（可选）最后一次 OverlayState（x/y/w/h）。
- 建议：分开两类数据
  - Settings：用户偏好（长期）
  - OverlayLastState：上次位置尺寸（体验提升，可选但建议做）

2) **SoundPlayer**
- 负责：播放轻量音效（仅在开关开启且不影响交互延迟时播放）。

### 5.6 Infra 模块
**Logger**
- 统一日志埋点：权限流程、show/hide/update、触摸事件关键点、异常与降级。

## 6. 接口定义（内部契约）

### 6.1 核心数据结构（建议直接落为 Java POJO/enum）
- `OverlayState`
  - `int widthPx, heightPx`
  - `int xPx, yPx`（相对屏幕左上）
  - `boolean visible`
  - `CloseButtonPosition closeButtonPosition`（LEFT_TOP/RIGHT_TOP）
  - `boolean soundEnabled`
  - `boolean isDragging, isResizing`（可选：便于动画策略）
- `ScreenBounds`
  - `int widthPx, heightPx`
  - `Insets safeInsets`（left/top/right/bottom）
- `AnimationSpec`
  - `long durationMs`
  - `AnimType type`（MOVE/RESIZE/FADE）
- `Settings`
  - `CloseButtonPosition closeButtonPosition`
  - `boolean soundEnabled`
- `OneShotEffect`
  - `PLAY_SOUND(type)`、`REQUEST_HIDE_AFTER_FADE`、`NAVIGATE_TO_PERMISSION` 等

### 6.2 关键接口签名（Java 8 风格）
- `FloatWindowController`
  - `void show(View contentView);`
  - `void hide();`
  - `boolean isShowing();`
  - `void update(Rect rectPx, @Nullable AnimationSpec anim);`
- `PermissionNavigator`
  - `boolean canDrawOverlays();`
  - `void openOverlayPermissionSettings(Activity activity);`
- `ScreenInfoProvider`
  - `ScreenBounds getCurrentBounds();`
  - `int dpToPx(float dp);`
- `SettingsRepository`
  - `Settings loadSettings();`
  - `void saveSettings(Settings settings);`
  - `@Nullable OverlayState loadLastOverlayState();`
  - `void saveLastOverlayState(OverlayState state);`
- `SoundPlayer`
  - `void playClick();`
  - `void setEnabled(boolean enabled);`

> 错误处理约定：Platform/Data 层捕获系统异常并返回可判定结果（或抛受检异常），Domain 统一记录日志并降级（例如更新失败→hide 并提示用户重新开启）。

**三级错误处理机制详情**：

1. **Platform 层（底层系统异常捕获）**：
   - 捕获系统异常：`SecurityException`（权限拒绝）、`WindowManager.BadTokenException`（窗口失效）、`IllegalStateException`（服务未启动）等
   - 转换策略：将系统异常转换为业务结果对象（`Result.success()` / `Result.error()`）或抛出领域异常
   - 不做业务降级，仅负责将底层错误向上传递

2. **Domain 层（业务逻辑异常处理）**：
   - 统一记录日志：捕获到的异常都需记录完整堆栈和上下文信息
   - 执行降级策略：
     - **权限拒绝**：触发 `NAVIGATE_TO_PERMISSION` 事件，引导用户前往设置
     - **窗口更新失败**：自动执行 `hideOverlay()`，记录错误日志，提示用户"窗口异常已自动关闭"
     - **服务启动失败**：回退到非保活模式（正常使用，但后台可能被杀），提示用户"保活功能暂时不可用"
     - **存储读写失败**：使用默认值并记录警告日志，不阻塞主流程
   - 错误恢复：提供重试机制（如权限被拒绝后，用户返回时自动重新检测）

3. **UI 层（用户友好的错误展示）**：
   - 捕获 UI 线程异常，避免应用崩溃
   - 根据错误类型提供用户友好提示（Toast/Dialog）
   - 阻塞操作提供加载状态和超时提示
   - 关键操作失败（如显示遮挡器）提供"重试"按钮

**具体场景处理示例**：
```java
// 伪代码示例
try {
    platformController.show(view);
} catch (SecurityException e) {
    Logger.error("悬浮窗权限被拒绝", e);
    // Domain 层降级
    viewModel.emitEffect(NAVIGATE_TO_PERMISSION);
    viewModel.updateState(state.with(visible=false));
} catch (WindowManager.BadTokenException e) {
    Logger.error("窗口失效，可能被系统回收", e);
    // Domain 层降级
    viewModel.emitEffect(SHOW_TOAST("窗口异常已自动关闭"));
    viewModel.updateState(state.with(visible=false));
}
```

## 7. 数据存储设计（Schema 描述）
使用 SharedPreferences（文件名建议：`subtitle_blocker_prefs`）：
- `close_button_position`：String（`LEFT_TOP`/`RIGHT_TOP`）
- `sound_enabled`：boolean
- `last_width_px` / `last_height_px` / `last_x_px` / `last_y_px`：int（可选）
- `prefs_version`：int（当前版本号，用于数据迁移）

**并发控制与线程安全**：
- 使用 `apply()` 异步提交（而非 `commit()` 同步提交）以避免主线程阻塞和 ANR
- Repository 方法需确保可从任意线程调用（内部通过 SharedPreferences 的线程安全机制保障）

**数据校验**：
- 读取位置/尺寸数据时验证数值合理性（如超出屏幕范围则使用默认值）
- 枚举值校验：读取 `close_button_position` 时需检查是否为有效枚举值，否则使用默认值 `RIGHT_TOP`

**版本迁移策略**：
```java
// 伪代码示例
void migrateData(SharedPreferences prefs, int currentVersion) {
    int savedVersion = prefs.getInt("prefs_version", 0);
    if (savedVersion < 1) {
        // 初始化默认值
        prefs.edit()
             .putInt("prefs_version", 1)
             .apply();
    }
    // 未来扩展：if (savedVersion < 2) { 迁移逻辑... }
}
```

**异常处理**：
- `loadLastOverlayState()` 返回 null 时提供默认状态（居中显示）
- 存储失败时记录警告日志，使用内存缓存或默认值继续运行（不阻塞主流程）

**未来优化建议**：
- 若项目已迁移至 Android Jetpack，建议使用 DataStore 替代 SharedPreferences（提供类型安全、事务性、协程支持）

索引/ER 图不适用（本应用无数据库表）。

## 8. 核心业务逻辑（流程与伪代码）

### 8.1 显示遮挡器流程
1) UI 点击"开启遮挡"
2) `if !PermissionNavigator.canDrawOverlays()` → 跳转系统设置并提示
3) 权限已具备：
   - 读取 `Settings` 与 `LastOverlayState`
   - 计算初始 `OverlayState`（默认居中/底部偏上，且 clamp 到屏幕）
   - `FloatWindowController.show(view)`
   - `FloatWindowController.update(rect, null)`
   - 如启用保活 → `KeepAliveService.startForeground(...)`

### 8.2 拖动/缩放/吸附/边界（VM 内统一计算）
关键原则：**所有位置尺寸都以 px 作为最终计算单位**；dp 只用于阈值/默认值输入。

伪代码（缩略但可直接指导实现）：
```text
onDragMove(dx, dy):
  // 拖动过程：直接更新位置,不触发动画(避免抖动和掉帧)
  s = state
  candidateX = s.xPx + dx
  candidateY = s.yPx + dy
  clamped = clampPosition(candidateX, candidateY, s.widthPx, s.heightPx, bounds)
  state = s.with(x=clamped.x, y=clamped.y, isDragging=true)
  emit(state, null)  // 无动画,直接更新 View 布局

onDragEnd():
  // 拖动结束:执行边缘吸附并触发平滑动画
  snapped = snapToEdgeIfNeeded(state, bounds, thresholdPx=dpToPx(15))
  state = snapped.with(isDragging=false)
  persistLastState(state)
  emit(state, MOVE(150ms))  // 触发 150ms 平滑移动动画

onResizeMove(dw, dh):
  // 缩放过程:直接更新尺寸,不触发动画
  candidateW = state.widthPx + dw
  candidateH = state.heightPx + dh
  w = clamp(candidateW, minW=dpToPx(100), maxW=bounds.widthPx*0.8)
  h = clamp(candidateH, minH=dpToPx(40),  maxH=bounds.heightPx*0.8)
  (x,y) = clampPosition(state.xPx, state.yPx, w, h, bounds) // 防越界
  state = state.with(width=w,height=h,x=x,y=y,isResizing=true)
  emit(state, null)  // 无动画,直接更新 View 布局

onResizeEnd():
  // 缩放结束:触发平滑尺寸动画
  state = state.with(isResizing=false)
  persistLastState(state)
  emit(state, RESIZE(200ms))  // 触发 200ms 平滑缩放动画
```

关键实现点：
- `clampPosition(x,y,w,h,bounds)`：确保 `x ∈ [insets.left, bounds.width - insets.right - w]`，`y ∈ [insets.top, bounds.height - insets.bottom - h]`
- `snapToEdgeIfNeeded`：若 `x` 距左边界或右边界 <= threshold → 吸附到对应边界（优先最近边）
- 动画策略：
  - **拖动/缩放过程中**：使用直接 layout 更新（`emit(state, null)`），保证 <150ms 实时响应
  - **拖动/缩放结束时**：触发 150/200ms 平滑动画收敛到最终状态
  - **原理**：过程高频更新避免频繁启动属性动画（会抖动/掉帧）；结束时一次性动画提升视觉体验

#### 8.2.1 动画实现技术细节

**1. 拖动动画（150ms 平滑移动）**
```java
// 拖动结束时触发边缘吸附动画
ValueAnimator moveAnim = ValueAnimator.ofFloat(startX, targetX);
moveAnim.setDuration(150);
moveAnim.setInterpolator(new DecelerateInterpolator()); // 减速效果
moveAnim.addUpdateListener(animation -> {
    float progress = animation.getAnimatedFraction();
    float currentX = startX + (targetX - startX) * progress;
    float currentY = startY + (targetY - startY) * progress;
    // 使用 View.layout() 直接设置位置（不触发 requestLayout）
    view.setLeft((int)currentX);
    view.setTop((int)currentY);
    view.setRight((int)(currentX + view.getWidth()));
    view.setBottom((int)(currentY + view.getHeight()));
});
moveAnim.start();
```

**2. 缩放动画（200ms 平滑尺寸变化）**
```java
// 缩放结束时触发尺寸收敛动画
ObjectAnimator widthAnim = ObjectAnimator.ofInt(view, "width", startWidth, targetWidth);
ObjectAnimator heightAnim = ObjectAnimator.ofInt(view, "height", startHeight, targetHeight);
AnimatorSet resizeAnim = new AnimatorSet();
resizeAnim.playTogether(widthAnim, heightAnim);
resizeAnim.setDuration(200);
resizeAnim.setInterpolator(new AccelerateDecelerateInterpolator());
resizeAnim.start();
```

**3. 关闭渐隐动画（300ms 淡出）**
```java
// 关闭时触发透明度动画
view.animate()
    .alpha(0f)
    .setDuration(300)
    .setInterpolator(new LinearInterpolator())
    .withEndAction(() -> {
        // 动画结束后销毁/隐藏悬浮窗
        floatWindowController.hide();
    })
    .start();
```

**4. 性能优化措施**
- **硬件加速**：动画开始前设置 `view.setLayerType(View.LAYER_TYPE_HARDWARE, null)`，动画结束后恢复 `LAYER_TYPE_NONE`
- **避免重绘监听**：动画过程中禁用 `ViewTreeObserver.OnPreDrawListener`，避免不必要的测量和布局
- **动画取消处理**：用户中断操作时调用 `animator.cancel()`，避免状态不一致
- **内存优化**：动画结束后及时释放 `Animator` 对象，避免内存泄漏

**5. 动画状态管理**
```java
// ViewModel 中管理动画状态
class OverlayViewModel {
    private ValueAnimator currentAnimator;

    private void cancelCurrentAnimation() {
        if (currentAnimator != null && currentAnimator.isRunning()) {
            currentAnimator.cancel();
        }
    }

    private void startMoveAnimation(float fromX, float toX, float fromY, float toY) {
        cancelCurrentAnimation(); // 取消旧动画
        currentAnimator = ValueAnimator.ofFloat(0f, 1f);
        currentAnimator.setDuration(150);
        currentAnimator.addUpdateListener(anim -> {
            float progress = anim.getAnimatedFraction();
            float x = fromX + (toX - fromX) * progress;
            float y = fromY + (toY - fromY) * progress;
            // 更新 UI
        });
        currentAnimator.start();
    }
}
```

### 8.3 关闭流程
1) 点击 close：
2) VM 发出 `FADE(300ms)` 与 `REQUEST_HIDE_AFTER_FADE`
3) View 执行 alpha 动画；结束回调触发 `FloatWindowController.hide()`；Domain 停止保活服务。

### 8.4 旋转/屏幕变化处理
- `onBoundsChanged(newBounds)`：
  - 重新执行 `clampPosition`（必要时调整 x/y 让其仍在可视范围）
  - 若最大宽高受新屏幕约束影响，执行 `clampSize` 后再 clamp position
  - 更新窗口布局

## 9. "前后端交互"与状态管理说明
- **前端（UI）**：Activity/Fragment + OverlayWindowView，负责展示与采集输入。
- **后端（本地能力层）**：Domain + Platform（权限、悬浮窗、服务、屏幕信息、存储）。
- **通信协议**：本地方法调用 + `OverlayState` 单向数据流（UI 事件→VM→State→View 渲染），避免跨模块共享可变全局状态。
- **认证授权**：不涉及账号体系；唯一权限为"悬浮窗权限"（以及前台服务/通知相关权限按系统要求处理）。

## 10. 代码结构与开发规范（建议目录）
以典型 Android 工程为例（按包分层）：
- `.../ui/`：Activity/Fragment、OverlayWindowView、ViewBinder
- `.../vm/`：OverlayViewModel、Effect/Intent/Reducer（如采用）
- `.../domain/`：OverlayInteractor、UseCases
- `.../platform/`：FloatWindowController(FloatingX 实现)、PermissionNavigator、ScreenInfoProvider、KeepAliveService
- `.../data/`：SettingsRepository(Sp 实现)、SoundPlayer 实现
- `.../infra/`：Logger（统一入口）

规范要点：
- 命名：类名名词化（Controller/Repository/Provider），方法动词化（show/hide/update/load/save）。
- 复杂逻辑：对"为什么这么算"（吸附、insets、动画策略）加中文注释。
- 日志：统一 Logger；禁止随意 `System.out/Log.d` 分散打点。
- 可测试性：VM/Domain 不直接持有 Android 组件；通过接口注入替身。

## 11. 测试策略与用例规划

### 11.1 单元测试（优先）
建议对纯逻辑（无 Android 依赖）做 JVM 单测：
- `clampSize`：
  - 小于最小值→回到最小；大于最大值→回到最大；边界值等于限制→保持
  - **新增**：负值输入测试；零尺寸窗口测试；超大尺寸测试（Integer.MAX_VALUE）
- `clampPosition`：
  - 四边越界分别回收；含 insets 情况；宽高变化后仍可见
  - **新增**：负坐标输入测试；窗口大于屏幕时的处理
- `snapToEdgeIfNeeded`：
  - 靠左/靠右/都不靠/左右等距（定义优先策略）
  - **新增**：边界阈值测试（恰好等于 15dp）；零窗口时的处理
- `OverlayViewModel`：
  - Drag/Resize 事件序列后的 state 正确
  - onCloseClick 产生 fade effect
  - onBoundsChanged 后 state 被 clamp
  - **新增**：快速连续事件测试（防抖）；拖动中缩放并发；缩放中拖动并发
- `SettingsRepository`：
  - 保存后读取一致；默认值策略
  - **新增**：版本迁移测试；数据损坏时的默认值回退；并发读写测试

### 11.2 集成测试（设备/模拟器）
- 权限流程：
  - 未授权→跳设置→返回→成功显示
  - 拒绝/未开启→不崩溃，UI 提示明确
  - **新增**：权限被撤销后重试流程；权限状态变化后的自动检测
- FloatingX 集成：
  - show→update→hide 时序正确；快速重复点击开关不泄漏
  - **新增**：窗口被系统强制回收后的恢复；多次旋转快速切换场景
- 旋转：
  - 旋转前后遮挡器仍在屏幕内；手势栏/刘海设备下不被遮挡
  - **新增**：旋转过程中拖动的处理；连续快速旋转（180°→0°→180°）
- 前台服务：
  - 启动后通知存在；停止后释放；Android 14 相关限制路径无异常
  - **新增**：服务被系统强制停止的处理；内存压力下的服务保活测试；通知被用户清除后的恢复
- 性能与稳定性测试（新增）：
  - 低内存情况下的稳定性（使用开发者选项限制内存）
  - 长时间运行稳定性（连续拖动/缩放 1000 次无崩溃）
  - 多任务切换后的资源释放

## 12. 部署、运维与监控考虑
- **发布**：标准 APK，minSdk 21，targetSdk 34（Android 14）。
- **运行时可观测性**：
  - 关键日志：权限检测结果、show/hide/update 参数、异常堆栈、服务启动停止、屏幕 bounds/insets。
  - （可选）本地导出日志：仅在 debug/开发版提供，避免泄露隐私。
- **隐私**：不采集用户内容，不读取屏幕内容；仅使用系统悬浮窗能力。

## 13. 潜在风险与缓解方案
- **保活不可 100% 保证**：系统可能仍会杀进程；缓解：合规前台服务 + 失败可恢复（重启后恢复 last state）。
- **高频动画导致掉帧**：拖动/缩放过程中频繁启动动画会卡顿；缓解：过程 direct layout，结束才用 150/200ms 动画收敛。
- **不同机型 Insets 差异**：全面屏手势栏/刘海处理不一致；缓解：统一通过 WindowInsets 计算 safeInsets，并在集成测试覆盖主流机型/模拟器配置。
- **权限引导体验差**：用户无法理解为何需要权限；缓解：在 UI 中明确说明用途，并提供"一键跳转设置"与返回后的自动检测。

## 14. 里程碑与任务分解建议（按实现顺序）
1) 基础工程与依赖：集成 FloatingX；搭建分层包结构与 Logger。
2) 最小可用悬浮窗：纯黑遮挡 View + show/hide + 权限引导。
3) 交互 MVP：拖动 + 边界限制 + 结束移动动画。
4) 缩放能力：右下手柄 + 尺寸限制 + 结束缩放动画。
5) 吸附与设置：15dp 吸附；关闭按钮左右切换；设置页与持久化。
6) 关闭体验：渐隐 300ms + 关闭后销毁；音效开关（可选）。
7) 旋转/多尺寸适配：bounds/insets 变化处理；完善兼容性。
8) 保活：前台服务策略与 Android 14 合规验证。
9) 测试与稳定性：补齐单测/集成测试；压力与边界场景回归。

**上下文引用**
- [简单实现框架文件.md](file:///d:/project/zimuzhedang/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%A1%86%E6%9E%B6%E6%96%87%E4%BB%B6.md)
- [实现文档.md](file:///d:/project/zimuzhedang/%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3.md)
- [项目描述文件.md](file:///d:/project/zimuzhedang/%E9%A1%B9%E7%9B%AE%E6%8F%8F%E8%BF%B0%E6%96%87%E4%BB%B6.md)